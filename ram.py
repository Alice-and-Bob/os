# 3、内存管理
# 申请一块64字节的内存空间模拟内存，按逻辑划分为16块，每块4B。
# 将目录中选中的文件读入内存，显示文件中信息。内存可以同时显示多个文件信息，每个文件固定分配4个内存块，
# 如果4个内存块不能显示文件全部信息，采用页面置换策略，将已显示完的页换出内存，可以选择的置换策略有，
# 全局置换、局部置换、FIFO、LRU。内存管理需要支持：
# DONE:（1）分配内存块：为线程分配内存块，每个线程默认分配4块。
# DONE:（2）回收内存：线程结束后回收其内存。
# DONE:（3）空闲内存块管理：为进入内存的数据寻找空闲内存块。没有空闲内存时，应给出提示。
# TODO:（4）块时间管理：提供数据块进入模拟内存的时间、访问时间的记录和查询功能，为页面置换算法提供支持，当某个内存块被选中时，更新其访问时间。


import threading
import time

# 16*4B的模拟内存
ram = []
chunk = b'\x00\x00\x00\x00'  # 一个块4字节
for i in range(0, 16):  # RAM共计16块，16*4字节
    ram.append(chunk)

# 内存管理表
ram_manage = []
item = {'time': 0,  # 进入内存的时间
        'is_free': 1  # 是否空闲
        }
for i in range(0, 16):
    ram_manage.append(item)

# FIXME：在内存块被换出时通过调用线程的对换方法换出，以便于通知线程更改页表；
# FIXED：对内存读写加锁，访问ram都要申请锁，在同一时间线上只允许一个线程进行内存读或写的操作

# FIXED:线程结束时回收占用的内存

# 内存读写锁
lock = threading.Semaphore(1)


# 空闲空间管理
def malloc_free_block():
    """
    用于尝试给调用者分配四块内存块，并维护内存管理表对分配的内存块进行状态更新
    :return:成功分配返回一个list，内容为四个分配的内存块块号，范围在[0,15]
            分配失败返回 -1
    """
    pass


# 回收线程内存
def recycle_ram(used_chunk):
    """
    线程结束时调用该方法，传入线程此时占用的内存块的块号，由此方法进行释放和初始化
    :param used_chunk: 准备结束的线程正在占用的内存块的块号
    :return:NULL
    """


# 内存块置换
def global_fifo():
    """
    采用全局可变分配，若线程提出多于四个内存块的请求，则首先挑选足够的空闲块分配给进程；当空闲块全部分配完毕，则启用全局FIFO置换策略，
    根据内存管理表中存在时间选择一个内存块换出，直到满足当前线程需要的内存空间大小
    :return:返回ans = (int(chunk_num),int(flag))
                        [0,15]     0：该内存是空闲块；1：该内存是对换块
    """
    pass


# 数据调入
def data_to_ram(data, free_block):
    """
    用于把执行线程的数据调入预先分配的4个内存块内，同时要维护块管理表；若数据多于4块，则启用块置换算法，选择某一块调入对换区内
    :param free_block:
    :param data: 要调入的数据；list
    :return: NULL
    """
    pass


# 内存目前状态显示
def display_ram():
    for ram_chunk in ram:
        print(ram_chunk)
